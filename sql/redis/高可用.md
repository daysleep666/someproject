
主从，双活，集群，功能性

## 主从

一. 安装

    1. 拉最新代码
    docker pull redis

    2. 启动3个redis节点
        docker run --name redis-6379 -p 6379:6379 -d redis:latest redis-server # ip为172.17.0.2  
        docker run --name redis-6380 -p 6380:6379 -d redis:latest redis-server
        docker run --name redis-6381 -p 6381:6379 -d redis:latest redis-server

    3. 设置为从节点
    docker exec -ti redis-6380 redis-cli
    SLAVEOF 172.17.0.2 6379

    docker exec -ti redis-6381 redis-cli
    SLAVEOF 172.17.0.2 6379

二. feature

    2.1 读写分离。写在master上，读在slave上，有效降低master压力。

    2.2 如果master挂了，slave可以成为master，保证业务正常运行。

三. 同步

    1. 同步策略
    1.1 全量同步
        触发：
            - slave初始化
            - slave发送SYNC
        坑：
            过多的slave执行sync操作会导致master的io剧增，有可能会挂掉。

    [图]

    2.2 增量同步
        将收到的写命令同步给slave

    [图]

四. 架构

    2.1 一主多从：

        [图]

    2.3 级联：

        [图]

五. 故障

    1. slave挂掉
       slave挂掉只会影响级联的子节点，不会影响master，重启之后会重新执行全量同步。

    2. master挂掉
       2.1 选择一个slave节点升级为master节点
       2.2 修改其他slave节点的master地址
       2.3 修改客户端指向的master节点
    人工操作非常麻烦，这个时候可以祭出sentinel

六. sentinel (哨兵)

    1. 启动
        进入三台redis节点，启动sentinel
        docker exec -ti redis-6379 redis-cli
        echo "sentinel monitor mymaster 172.17.0.2 6379 2" > sentinel.conf
        echo "protected-mode no" >> sentinel.conf
        nohup redis-sentinel sentinel.conf > sen.log &

    2. 特性
        2.1 监控节点存活
            定时发送ping，心跳检测。    
        2.2 自动故障转移
            提升一个slave节点为master节点
            修改其他slave节点指向的master

    3. 自动故障转移
        3.1 如果监听到一个slave宕机，就将它标记为下线。
        3.2 如果监听到一个master宕机，这时候称master节点是主观下线
            当有至少x个sentinel认为master节点宕机时，这时候称这个master是客观下线，准备自动故障转移。
            [sentinel monitor mymaster ip port x]指的这个。x要大于sentinel数量的一半。
        3.3 通过raft算法选举出一个sentinel leader
        3.4 sentinel leader选择一个slave成为master,发送slaveof no one
        3.5 sentinel leader向其他slave更改master,发送slaveof masterIP masterPORT
        每个纪元(epoch)只会有一个leader产生，当出现网络分割时，以新epoch为主。

    4. 架构
        [图]

高可用

一.主从

1. performance

    1.1 读写分离。写在master上，读在slave上，有效降低master压力。

    1.2 如果master挂了，slave可以成为master，保证业务正常运行。

2. 架构

    2.1 一主多从：

    2.3 级联：

二.集群

1. performance

    1.1 数据分片。将数据分配到多个节点上，避免一个节点承受大数据访问发生崩溃的问题。

2. 架构

3. 算法

    3.1 hash slot:

三.双活

1. performance

    1.1 双master节点，互相备份，同时为外部提供服务。
    1.2 其中一个节点挂了，另一个节点可以保持服务正常运行。

2. 架构

四. 为了避免缓存穿透，外面加一层布隆过滤器.



解决方案    https://www.infoq.cn/article/2014/11/open-source-redis-cache/