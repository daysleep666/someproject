
主从，双活，集群，功能性
raft

## 主从

一. 安装

    1. 拉最新代码
    docker pull redis

    2. 启动3个redis节点
        docker run --name redis-6379 -p 6379:6379 -d redis:latest redis-server # ip为172.17.0.2  
        docker run --name redis-6380 -p 6380:6379 -d redis:latest redis-server
        docker run --name redis-6381 -p 6381:6379 -d redis:latest redis-server

    3. 设置为从节点
    docker exec -ti redis-6380 redis-cli
    SLAVEOF 172.17.0.2 6379

    docker exec -ti redis-6381 redis-cli
    SLAVEOF 172.17.0.2 6379

二. 特性

    2.1 读写分离。写在master上，读在slave上，有效降低master压力。

    2.2 如果master挂了，slave可以成为master，保证业务正常运行。

三. 同步

    1. 同步策略
    1.1 全量同步
        触发：
            - slave初始化
            - slave发送SYNC
        坑：
            过多的slave执行sync操作会导致master的io剧增，有可能会挂掉。

    [图]

    2.2 增量同步
        将收到的写命令同步给slave

    [图]

四. 架构

    2.1 一主多从：

        [图]

    2.3 级联：

        [图]

五. 故障

    1. slave挂掉
       slave挂掉只会影响级联的子节点，不会影响master，重启之后会重新执行全量同步。

    2. master挂掉
       2.1 选择一个slave节点升级为master节点
       2.2 修改其他slave节点的master地址
       2.3 修改客户端指向的master节点
    人工操作非常麻烦，这个时候可以祭出sentinel

六. sentinel (哨兵)

    1. 启动

    2. 特性
        2.1 监控节点存活
            定时发送ping，心跳检测。    
        2.2 自动故障转移
            提升一个slave节点为master节点
            修改其他slave节点指向的master

    3. 自动故障转移
        3.1 如果监听到一个slave宕机，就将它标记为下线。
        3.2 如果监听到一个master宕机，这时候称master节点是主观下线
            当有至少x个sentinel认为master节点宕机时，这时候称这个master是客观下线，准备自动故障转移。
            [sentinel monitor mymaster ip port x]指的这个。x要大于sentinel数量的一半。
        3.3 通过raft算法选举出一个sentinel leader
        3.4 sentinel leader选择一个slave成为master,发送slaveof no one
        3.5 sentinel leader向其他slave更改master,发送slaveof masterIP masterPORT
        每个纪元(epoch)只会有一个leader产生，当出现网络分割时，以新epoch为主。

    4. 架构

        [图]

-------------------------

## 集群

一. 安装`

二. 特性

    1. 主从自动故障转移
    2. 数据分片。减轻单节点压力。

三. 数据分片

    1. 一共有16384个哈希槽，所有的key经过CRC16(key)%16384后都会落到其中一个哈希槽。(CRC16循环冗余校验)
    [图]

    2. 增加节点。就是将每个节点的一部分哈希槽拿出来放到新节点。
    [图]

    3. 移除节点。就是将被移除的节点的哈希槽拿到其他节点，然后在移除空节点。
    [图]

四. 故障转移
    
    和sentinel的故障转移一样

五. 架构

    [图]

六.　集群解决方案

[解决方案](https://www.infoq.cn/article/2014/11/open-source-redis-cache/ "解决方案")
   
1. NetFlix 对 Dynamo 的开源通用实现

    [Dynamo](https://github.com/Netflix/dynomite "Dynomite")
    基于C/C++开发


2. Twitter 的 Redis/Memcached 代理服务 Twemproxy

    [Twemproxy](https://github.com/twitter/twemproxy "Twemproxy")
    基于C开发

3. 豌豆荚的 Redis 集群解决方案 Codis

    [Codis](https://github.com/CodisLabs/codis "Codis")
    基于GO和C开发

-------------------------

## 双活

    一. 特性
        1. 互为备份。冗余存储，零数据丢失。两个节点都可以读和写，如果一个挂了，另一个节点可以无缝接替全部请求。
        2. 同时对外提供同种业务，随时切换。

    二. 模型
        1. 主主模型。
            按访问者ip决定此时应该访问哪个节点。
            [图]

        2. 分业务主备
            根据业务来决定此时应该访问哪个节点
            [图]


    三. 同步

        1.一致性方案
            1.1 实时同步
                写完节点a,在写节点b,然后才算成功.一致性高,但是对两个节点间的速度要求非常高.
            1.2 异步
                写完节点a就直接算成功,同步这事是在后台慢慢跑的.一致性没有同步方案高,假设节点a在
                写完数据后没来得及同步就挂了,会造成数据丢失.

        2. 双写,但是在每一个时刻是单向的
            假设一种极端情况，某个字段在节点ａ被写为１，同一时刻这个字段在节点ｂ被写为２，双方互相写
            的话会将对方的覆盖掉从而导致两个节点的值不一致。所以这个时候要求同一时刻只能有一个节点在往另
            一个节点同步.

        3. 将写命令发送给另一节点.写命令可以从缓冲区里拿,也可以从aof的文件中拿.

-------------------------

## 缓存失效

    一. 缓存穿透
        
        在redis中访问一个key发现它不存在,就会继续访问数据库,这时候redis就起不到缓存的作用了.通过不存在的key恶意攻击.

        1.解决方案
            1.1 缓存不存在的key,值设为零值
            1.2 套一个布隆过滤器.
                一个key经过hash后落到一个int64的某一二进制位上,如果二进制为1则存在,反之不存在.
                [图]

    二. 缓存雪崩

        所有的key在同一时间失效,导致数据库访问量瞬间增大.

        1. 解决方案
            1.1 key设置random的过期时间.不同一时间失效就好.

## 一致性哈希

    根据哈希结果来决定应该访问哪个节点

    1. 先看下根据普通哈希算法分配流量

        hash(ip) % 节点数量

        无论增加还是减少节点数量,都会导致大部分key失效

    2. 一致性哈希算法
        将节点ip映射(hash)到一个环上,key也映射(hash)到这个环上某一点,然后顺时针找到最近的那个节点.
        
        [图]

        2.1 增加节点只会影响部分key的映射.

        [图]   

        2.2 减少节点只会影响部分key的映射.

        [图]   

## 共识算法

    这个算法源于拜占庭将军问题

    有一个元帅和四个将军,平常都是元帅发布命令,将军去做的

    [图]

    突然有一天元帅吃寒汉堡噎死了

    [图]

    四个将军中有个判断,他趁元帅死了,开始发布错误的命令坑队友.

    [图]

    这就是一个简单的拜占庭将军问题.

    为了解决这个问题就需要一个共识算法.

    以raft算法举例.

    在失去leader之后,每个节点都会启动一个随机定时器,定时器到头之后的那个节点成为candidate.
    candidate给其他节点发请求,要求他们给自己投票,让自己当leader.

    [图]

    当超过半数节点同意自己后,从candidate升为leader

    [图]

## 功能点

### 架构

    redis是单线程架构

    [图]

    所有的命令都会进入一个命令队列串行执行

    速度快的理由:

        1. 在内存中
        2. 多路io复用
                你是一个富豪,你有一个专门的厨师为你做饭
            2.1 阻塞io
                你饿了,要求厨师给你做饭,然后就坐到饭桌前直到饭做好了为止.

            2.2 非阻塞io
                你又饿了,要求厨师给你做饭,但是你这回躺在了床上每过一段时间就去问下厨师有没有做好饭.

            2.3 多路复用io
                你破产了,你跟别人共用一个厨师,你需要等厨师做完上一个人的菜才能为你做菜.
                    [图]

        3. 单线程
           3.1 不需要线程切换.没有性能损耗
           3.2 不存在并发,不需要加锁

### 过期策略

    1. 定期删除

       每隔一段时间,随机检查n个key,如果过期了,就干掉它.

    2. 惰性删除

       每当访问一个key的时候,检查它是否过期,过期就删除

    3. LRU  [这个跟过期没关系了,主要是内存如果满了,怎么办]
    
       如果内存空间满了,默认删除最近最少使用的key.

### redis和数据库双写一致

    在更新数据库和更新redis时可能会出现不一致产生脏数据.

    解决方案:
        
        1. 设置过期时间.

        2. 如果不能设置过期时间,可以采取延后删除缓存的策略.

            举个例子
            线程a删除缓存
            线程b读取缓存,读不到
            线程b读取数据库,读取了旧的值
            线程b将旧值写入缓存
            线程a修改数据库为新值.

            在线程a删除缓存和修改数据库间出现了不一致,导致线程b写入了脏值.所以在线程a修改完数据库后需要删除缓存.

### redis为什么不推荐做为数据库使用

    1. 备份

        1.1 rdb 全备份,当前数据的快照

            每隔一定时间备份一次,如果在两次备份间挂掉,那期间的数据都丢了

        1.2 aof 写命令追加日志

            1.2.1 实时写,每有一个写操作就要写下磁盘,会严重影响redis的性能.redis之所以快就是因为纯内存操作,一般没有磁盘io,

            1.2.2 攒一段时间一起写,容易丢失数据.

    2. redis启动的时候会将全部数据加载到内存.如果数据量非常大,启动会很慢,也会很占内存.